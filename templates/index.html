<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>P2P Translation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 1rem;
            text-align: center;
        }
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 600px;
            margin: 0 auto;
            padding: 1rem;
        }
        .hidden {
            display: none;
        }
        .screen {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 0.5rem;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .mic-button {
            height: 80px;
            border-radius: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            font-size: 1.5rem;
            font-weight: bold;
        }
        .mic-button:active, .mic-button.recording {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }
        .message {
            max-width: 80%;
            padding: 0.75rem;
            border-radius: 0.75rem;
            margin-bottom: 0.5rem;
        }
        .message.sent {
            background-color: #dcf8c6;
            align-self: flex-end;
        }
        .message.received {
            background-color: white;
            align-self: flex-start;
        }
        .session-info {
            background-color: #e9ecef;
            padding: 0.5rem;
            border-radius: 0.5rem;
            text-align: center;
            margin-bottom: 1rem;
        }
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.25rem;
        }
        .status-dot.connected {
            background-color: #28a745;
        }
        .status-dot.disconnected {
            background-color: #dc3545;
        }
        .language-label {
            font-size: 0.8rem;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>P2P Translation</h1>
    </div>
    
    <!-- Home Screen -->
    <div id="home-screen" class="screen container">
        <div class="d-grid gap-3">
            <button id="create-button" class="btn btn-primary btn-lg">Create New Conversation</button>
            <button id="join-button" class="btn btn-outline-primary btn-lg">Join Conversation</button>
        </div>
    </div>

    <!-- Create Screen -->
    <div id="create-screen" class="screen container hidden">
        <h2 class="mb-4">Create Conversation</h2>
        <form id="create-form">
            <div class="mb-3">
                <label for="your-language" class="form-label">Your Language</label>
                <select id="your-language" class="form-select" required></select>
            </div>
            <div class="mb-3">
                <label for="their-language" class="form-label">Their Language</label>
                <select id="their-language" class="form-select" required></select>
            </div>
            <div class="d-grid gap-2">
                <button type="submit" class="btn btn-primary">Create</button>
                <button type="button" class="btn btn-outline-secondary back-button">Back</button>
            </div>
        </form>
    </div>

    <!-- Join Screen -->
    <div id="join-screen" class="screen container hidden">
        <h2 class="mb-4">Join Conversation</h2>
        <form id="join-form">
            <div class="mb-3">
                <label for="session-id" class="form-label">Conversation Code</label>
                <input type="text" id="session-id" class="form-control form-control-lg text-center" placeholder="Enter code" required>
            </div>
            <div class="mb-3">
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="position" id="position-1" value="1" checked>
                    <label class="form-check-label" for="position-1">Position 1</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="position" id="position-2" value="2">
                    <label class="form-check-label" for="position-2">Position 2</label>
                </div>
            </div>
            <div class="d-grid gap-2">
                <button type="submit" class="btn btn-primary">Join</button>
                <button type="button" class="btn btn-outline-secondary back-button">Back</button>
            </div>
        </form>
    </div>

    <!-- Translation Screen -->
    <div id="translation-screen" class="screen container hidden">
        <div class="session-info">
            <div><strong>Session ID: </strong><span id="session-display"></span></div>
            <div>
                <span class="status-dot disconnected" id="connection-dot"></span>
                <span id="connection-status">Waiting for other user...</span>
            </div>
        </div>
        
        <div class="chat-area" id="chat-area">
            <!-- Messages will appear here -->
        </div>
        
        <div class="controls">
            <button id="mic-button" class="mic-button">Hold to Speak</button>
            
            <div id="share-section" class="mt-3">
                <p>Share this session with your conversation partner:</p>
                <div class="input-group">
                    <input type="text" id="share-link" class="form-control" readonly>
                    <button class="btn btn-outline-secondary" id="copy-button">Copy</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
        // DOM Elements
        const homeScreen = document.getElementById('home-screen');
        const createScreen = document.getElementById('create-screen');
        const joinScreen = document.getElementById('join-screen');
        const translationScreen = document.getElementById('translation-screen');
        
        const createButton = document.getElementById('create-button');
        const joinButton = document.getElementById('join-button');
        const backButtons = document.querySelectorAll('.back-button');
        
        const createForm = document.getElementById('create-form');
        const joinForm = document.getElementById('join-form');
        
        const yourLanguageSelect = document.getElementById('your-language');
        const theirLanguageSelect = document.getElementById('their-language');
        const sessionIdInput = document.getElementById('session-id');
        
        const micButton = document.getElementById('mic-button');
        const chatArea = document.getElementById('chat-area');
        
        const sessionDisplay = document.getElementById('session-display');
        const connectionDot = document.getElementById('connection-dot');
        const connectionStatus = document.getElementById('connection-status');
        
        const shareLink = document.getElementById('share-link');
        const copyButton = document.getElementById('copy-button');
        
        // Session state
        let sessionId = null;
        let userId = null;
        let userPosition = null;
        let socket = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            // Fetch languages for dropdowns
            fetchLanguages();
            
            // Set up event listeners
            createButton.addEventListener('click', () => showScreen(createScreen));
            joinButton.addEventListener('click', () => showScreen(joinScreen));
            
            backButtons.forEach(button => {
                button.addEventListener('click', () => showScreen(homeScreen));
            });
            
            createForm.addEventListener('submit', handleCreateForm);
            joinForm.addEventListener('submit', handleJoinForm);
            
            micButton.addEventListener('mousedown', startRecording);
            micButton.addEventListener('mouseup', stopRecording);
            micButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startRecording();
            });
            micButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopRecording();
            });
            
            copyButton.addEventListener('click', copyShareLink);
            
            // Check URL for session info
            checkUrlParameters();
        });
        
        function showScreen(screen) {
            homeScreen.classList.add('hidden');
            createScreen.classList.add('hidden');
            joinScreen.classList.add('hidden');
            translationScreen.classList.add('hidden');
            
            screen.classList.remove('hidden');
        }
        
        async function fetchLanguages() {
            try {
                const response = await fetch('/languages');
                const languages = await response.json();
                
                // Populate dropdowns
                for (const [code, name] of Object.entries(languages)) {
                    const option1 = document.createElement('option');
                    option1.value = code;
                    option1.textContent = name;
                    
                    const option2 = document.createElement('option');
                    option2.value = code;
                    option2.textContent = name;
                    
                    yourLanguageSelect.appendChild(option1);
                    theirLanguageSelect.appendChild(option2);
                }
                
                // Default to English and Spanish
                yourLanguageSelect.value = 'en';
                theirLanguageSelect.value = 'es';
            } catch (error) {
                console.error('Error fetching languages:', error);
                alert('Failed to load languages. Please refresh the page.');
            }
        }
        
        async function handleCreateForm(e) {
            e.preventDefault();
            
            const yourLang = yourLanguageSelect.value;
            const theirLang = theirLanguageSelect.value;
            
            try {
                const response = await fetch('/create-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user1_lang: yourLang,
                        user2_lang: theirLang
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    sessionId = data.session_id;
                    
                    // Join as user 1
                    joinSession(sessionId, 1);
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.error || 'Failed to create session'}`);
                }
            } catch (error) {
                console.error('Error creating session:', error);
                alert('Failed to create session. Please try again.');
            }
        }
        
        async function handleJoinForm(e) {
            e.preventDefault();
            
            const session = sessionIdInput.value.trim();
            const position = document.querySelector('input[name="position"]:checked').value;
            
            if (!session) {
                alert('Please enter a session ID');
                return;
            }
            
            joinSession(session, parseInt(position));
        }
        
        async function joinSession(session, position) {
            try {
                const response = await fetch(`/join-session/${session}/${position}`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    sessionId = data.session_id;
                    userId = data.user_id;
                    userPosition = data.position;
                    
                    // Connect to socket
                    connectSocket();
                    
                    // Show translation screen
                    showScreen(translationScreen);
                    
                    // Update UI
                    sessionDisplay.textContent = sessionId;
                    
                    // Generate share link
                    const shareUrl = `${window.location.origin}?session=${sessionId}&position=${userPosition === 1 ? 2 : 1}`;
                    shareLink.value = shareUrl;
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.error || 'Failed to join session'}`);
                }
            } catch (error) {
                console.error('Error joining session:', error);
                alert('Failed to join session. Please try again.');
            }
        }
        
        function connectSocket() {
            // Disconnect existing socket if any
            if (socket) {
                socket.disconnect();
            }
            
            // Connect to Socket.IO server
            socket = io();
            
            // Set up event handlers
            socket.on('connect', () => {
                console.log('Connected to server');
                
                // Join session room
                socket.emit('join', {
                    session_id: sessionId,
                    user_id: userId
                });
            });
            
            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                connectionDot.classList.remove('connected');
                connectionDot.classList.add('disconnected');
                connectionStatus.textContent = 'Disconnected from server';
            });
            
            socket.on('joined', (data) => {
                console.log('Joined session:', data);
                
                if (data.other_user_connected) {
                    connectionDot.classList.remove('disconnected');
                    connectionDot.classList.add('connected');
                    connectionStatus.textContent = 'Other user connected';
                }
            });
            
            socket.on('user_joined', (data) => {
                console.log('Other user joined:', data);
                connectionDot.classList.remove('disconnected');
                connectionDot.classList.add('connected');
                connectionStatus.textContent = 'Other user connected';
            });
            
            socket.on('text_update', (data) => {
                console.log('Text update:', data);
                updateChatMessages(data);
            });
            
            socket.on('audio_update', (data) => {
                console.log('Audio update received');
                playAudio(data.audio);
            });
            
            socket.on('error', (data) => {
                console.error('Socket error:', data.message);
                alert(`Error: ${data.message}`);
            });
        }
        
        function updateChatMessages(data) {
            if (data.type === 'source') {
                // Update my message
                let messageEl = document.querySelector('.message.sent');
                
                if (!messageEl) {
                    messageEl = document.createElement('div');
                    messageEl.className = 'message sent';
                    chatArea.appendChild(messageEl);
                }
                
                messageEl.textContent = data.text;
            } else if (data.type === 'translation') {
                // Update their message
                let messageEl = document.querySelector('.message.received');
                
                if (!messageEl) {
                    messageEl = document.createElement('div');
                    messageEl.className = 'message received';
                    chatArea.appendChild(messageEl);
                }
                
                messageEl.textContent = data.text;
            }
            
            // Scroll to bottom
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        async function startRecording() {
            if (isRecording || !socket || !socket.connected) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });
                
                mediaRecorder.addEventListener('stop', () => {
                    processAudioChunks();
                });
                
                mediaRecorder.start();
                isRecording = true;
                
                // Update UI
                micButton.classList.add('recording');
                micButton.textContent = 'Release to Stop';
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Failed to access microphone. Please ensure your browser has permission to use the microphone.');
            }
        }
        
        function stopRecording() {
            if (!isRecording || !mediaRecorder) return;
            
            mediaRecorder.stop();
            isRecording = false;
            
            // Update UI
            micButton.classList.remove('recording');
            micButton.textContent = 'Hold to Speak';
        }
        
        async function processAudioChunks() {
            if (audioChunks.length === 0) return;
            
            try {
                // Create blob from chunks
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                
                // Convert to Float32Array
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = await decodeAudioData(arrayBuffer);
                
                // Convert to base64
                const audio_b64 = arrayBufferToBase64(audioData.buffer);
                
                // Send to server
                socket.emit('audio', {
                    session_id: sessionId,
                    user_id: userId,
                    audio: audio_b64
                });
            } catch (error) {
                console.error('Error processing audio:', error);
            }
        }
        
        async function decodeAudioData(arrayBuffer) {
            // Create audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Decode audio data
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Get first channel data
            const audioData = audioBuffer.getChannelData(0);
            
            // Resample to 16kHz if needed
            if (audioBuffer.sampleRate !== 16000) {
                return resampleAudio(audioData, audioBuffer.sampleRate, 16000);
            }
            
            return audioData;
        }
        
        function resampleAudio(audioData, originalSampleRate, targetSampleRate) {
            const ratio = targetSampleRate / originalSampleRate;
            const newLength = Math.floor(audioData.length * ratio);
            const result = new Float32Array(newLength);
            
            for (let i = 0; i < newLength; i++) {
                const index = Math.floor(i / ratio);
                result[i] = audioData[index];
            }
            
            return result;
        }
        
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            const binary = bytes.reduce((acc, byte) => acc + String.fromCharCode(byte), '');
            return window.btoa(binary);
        }
        
        function playAudio(audio_b64) {
            if (!audio_b64) return;
            
            try {
                // Decode base64
                const binaryString = window.atob(audio_b64);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // Convert to audio buffer
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = new Int16Array(bytes.buffer);
                const floatBuffer = new Float32Array(audioBuffer.length);
                
                // Convert Int16 to Float32
                for (let i = 0; i < audioBuffer.length; i++) {
                    floatBuffer[i] = audioBuffer[i] / 32767.0;
                }
                
                // Create buffer source
                const bufferSource = audioContext.createBuffer(1, floatBuffer.length, 16000);
                bufferSource.getChannelData(0).set(floatBuffer);
                
                // Play audio
                const source = audioContext.createBufferSource();
                source.buffer = bufferSource;
                source.connect(audioContext.destination);
                source.start();
            } catch (error) {
                console.error('Error playing audio:', error);
            }
        }
        
        function copyShareLink() {
            shareLink.select();
            document.execCommand('copy');
            alert('Link copied to clipboard!');
        }
        
        function checkUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const session = urlParams.get('session');
            const position = urlParams.get('position');
            
            if (session) {
                sessionIdInput.value = session;
                
                if (position && (position === '1' || position === '2')) {
                    document.getElementById(`position-${position}`).checked = true;
                }
                
                showScreen(joinScreen);
            }
        }
    </script>
</body>
</html>